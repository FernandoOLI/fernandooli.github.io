<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/>
    <meta name="description" content=""/>
    <meta name="author" content="Fernando Oliveira Pereira"/>
    <title>Codes</title>
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico"/>
    <!-- Font Awesome icons (free version)-->
    <script src="https://use.fontawesome.com/releases/v5.15.4/js/all.js" crossorigin="anonymous"></script>
    <!-- Google fonts-->
    <link href="https://fonts.googleapis.com/css?family=Varela+Round" rel="stylesheet"/>
    <link
            href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i"
            rel="stylesheet"/>
    <!-- Core theme CSS (includes Bootstrap)-->
    <link href="css/styles.css" rel="stylesheet"/>
</head>

<body id="page-top">
<!-- Navigation-->
<nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
    <div class="container px-4 px-lg-5">
        <a class="navbar-brand" href="index.html">Voltar</a>
        <button class="navbar-toggler navbar-toggler-right" type="button" data-bs-toggle="collapse"
                data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
                aria-label="Toggle navigation">
            Menu
            <i class="fas fa-bars"></i>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
            <ul class="navbar-nav ms-auto">
                <li class="nav-item"><a class="nav-link" href="index.html#about">Sobre</a></li>
                <li class="nav-item"><a class="nav-link" href="index.html#projects">Projetos</a></li>
                <li class="nav-item"><a class="nav-link" href="index.html#signup">Contato</a></li>
            </ul>
        </div>
    </div>
</nav>
<!-- Masthead-->

<!-- About-->
<section class="projects-section bg-light" id="projects">
    <div class="container px-4 px-lg-5">
        <!-- Featured Project Row-->
        <div class="row gx-0 mb-4 mb-lg-5 align-items-center">
            <div class="col-xl-8 col-lg-5">
                <div class="featured-text text-center text-lg-left row">
                    <div class="col-11">
                        <h3>Misty</h3>
                        <p class="text-black-50 mb-0">Projeto Normalização de Imagens e disponibilização em MongoDB
                        </p>
                        </br>
                    </div>
                    <div class="col-1">
                        <a class="mx-5" href="https://github.com/FernandoOLI/ImageConverterInMongoDB"
                           target="_blank"><i class="fab fa-github fa-4x"></i></a>
                    </div>
                </div>
            </div>
            <div class="col-xl-10 col-lg-7">
                <img class="img-fluid mb-3 mb-lg-0" src="assets/img/fluxo.JPG" alt="..."/>
            </div>

        </div>
        <div class="row gx-0 mb-4 mb-lg-5 align-items-center">
            <h4>Problema: </h4>
            <p> Para modelos de Inteligência Artificial (IA), em que o input são imagens, é necessário o
                processamento das mesmas. Trata-se de uma das partes mais onerosas, na qual é necessário muitos
                recursos computacionais.
            <h4>Objetivo:</h4>
            <p> O objetivo deste projeto é disponibilizar os dados das imagens processadas, de modo a otimizar o
                processo de execução dos modelos de IA , bem como, permitir consultas simultâneas das imagens
                processadas e parametrizadas.</p>
            </p>
            <h4>Descrição:</h4>
            <p>O projeto pode ser dividido em 3 partes:</p>
            <p>1- As imagens no formato original são salvas em um container da Azure. </p>
            <p>2- O código, construído em python, faz o download em lotes para processar as imagens.</p>
            <p>3- Os resultados são salvos no Mongo Atlas. </p>
            </p>


            <p>
            <h4>Variáveis da aplicação:</h4><br/>

            <p>Todos os parâmetros precisam estar salvos no arquivo '.env', localizado
                na raiz do projeto. Um exemplo de variável: AZURE_CONTAINER=container</p>
            &emsp;&emsp;ENVIROMENT -> Variável que determina se a aplicação irá rodar localmente ou com os dados da
            Azure ou MongoDb Atlas. <br/>
            &emsp;&emsp;Para local, inserir o valor ‘Local’ para Azure e ‘Cluster’ para MongoDb
            Atlas<br/>
            <p>
            <h5>Configurações para usar o MongoDb Atlas:</h5>
            &emsp;&emsp;CLIENT_DATABASE_ONLINE -> String de conexão com o MongoDb Atlas no formato:
            <br/>
            &emsp;&emsp;mongodb+srv://"DATABASE_USER":"ACCESS"@clusterimage id/"DATABASE_ONLINE" <br/>
            &emsp;&emsp;DATABASE_ONLINE -> Nome do database no MongoDb Atlas.<br/>
            &emsp;&emsp;ONLINE_ACCESS -> senha de usuário do database. <br/>
            &emsp;&emsp;COLLECTION_ONLINE -> Nome da collection no MongoDb Atlas.<br/>
            &emsp;&emsp;AZURE_STORAGE_CONNECTION_STRING -> String de conexão com Azure.<br/>
            &emsp;&emsp;AZURE_CONTAINER -> Nome do container principal da Azure.<br/>
            &emsp;&emsp;AZURE_BACKUP -> Nome do container principal da Azure.<br/>
            &emsp;&emsp;AZURE_NAME -> Nome do Storage<br/>
            &emsp;&emsp;TEMP_PATH -> Pasta dentro do projeto onde será usado para salvo as imagens por lotes.<br/>
            &emsp;&emsp;DATABASE_USER -> Nome do usuário do MongoDb<br/>

            <p>
            <h5>Configurações para usar o MongoDb localmente:</h5>
            &emsp;&emsp;PATH_BASE_ONLINE -> <br/>
            &emsp;&emsp;PATH_BASE_SINGLE_ONLINE -> <br/>
            &emsp;&emsp;CLIENT_DATABASE_LOCAL -> String de conexão com o MongoDb local<br/>
            &emsp;&emsp;DATABASE_LOCAL -> Nome do database local.<br/>
            &emsp;&emsp;COLLECTION_LOCAL -> Nome da collection no MongoDb local.<br/>
            &emsp;&emsp;PATH_BASE_LOCAL -><br/>
            &emsp;&emsp;PATH_BASE_SINGLE_LOCAL -><br/><br/>


            <p>
            <h5>Configurações para o processamento da imagem:</h5>
            &emsp;&emsp;BASEWIDTH -> Valor de referência de largura na conversão da imagem.<br/>
            &emsp;&emsp;BASEHEIGHT -> Valor de referência de altura na conversão da imagem.<br/>
            &emsp;&emsp;MIN_HEIGHT -> Valor mínimo da referência de largura na conversão da imagem.<br/>
            &emsp;&emsp;MIN_WIDTH -> Valor mínimo da referência de altura na conversão da imagem.<br/>
            &emsp;&emsp;NORMALIZE -> Valor booleano para indicar a normalização, true ocorre a normalização, false
            não ocorre.<br/>
            &emsp;&emsp;CONTADOR -> Valor definido para saber quantas imagens serão processadas simultaneamente.
            <br/>
            &emsp;&emsp;QUANTIDADE -> Quantidade de imagens que irão para o arquivo de amostra zip.</p>


            <p>Existe a opção de executar localmente ou usando o cluster. Para ser localmente, a variável
                ENVIROMENT, deve ser inicializada com o valor 'local'. A partir disso, serão usados os campos:
                CLIENT_DATABASE_LOCAL, DATABASE_LOCAL, COLLECTION_LOCAL e PATH_BASE_LOCAL.<br/>
                Para usar o Azure e o MongoDb Atlas, a variável ENVIROMENT, deve ser inicializada com o valor
                'cluster'. Com os seguintes campos: CLIENT_DATABASE_ONLINE, DATABASE_ONLINE, ONLINE_ACCESS,
                COLLECTION_ONLINE, AZURE_STORAGE_CONNECTION_STRING, AZURE_CONTAINER, AZURE_BACKUP e
                AZURE_NAME.<br/>
                Os dados de entrada, imagens, estão salvos em um container na Azure. O nome pode ser definido pela
                variável AZURE_CONTAINER. <br/>
                A aplicação ao ser executada, irá listar somente os nomes das imagens contidas no container. Em
                seguida, deve ser escolhido a quantidade de imagens a serem processadas, a qual é definida pelo
                parâmetro
                CONTADOR.<br/> <br/>
            <h5><u>Serão executados os seguintes passos:</u></h5><br/>
            Observação: Pode-se optar em normalizar o array final, fazendo variar de 0 a 1, ou deixar variando de 0
            a 255.
            Caso opte pela normalização, o campo NORMALIZE deve ser True, caso contrário False.</p><br/>

            <h5><b>1. Conversão para escala de cinza:</b></h5>
            A conversão para escala de cinza é feita antes da redução de tamanho, foi feito nessa ordem pois notou-se
            redução no tempo de processamento e gasto computacional, cerca de 30%.<br/>
            Para converter para a escala de cinza foi multiplicado as camadas RGB por 0.2989, 0.5870, 0.1140 e a
            soma é o valor na escala de cinza.</p>

            <h5><b>2. Redução do tamanho da imagem: </b></h5>
            Usando de base os campos BASEWIDTH, BASEHEIGHT, MIN_HEIGHT, MIN_WIDTH como parâmetros, é feita a redução
            da imagem. Os campos BASEWIDTH, BASEHEIGHT são para determinar os tamanhos de altura e largura da saída
            da imagem.
            </br>
            Considerando a largura como medida de referência, se sua medida original é maior que a BASEWIDTH, será
            feita a redução mantendo o valor de BASEWIDTH como largura e a altura será calculada. Similarmente , se
            a altura é menor que MIN_HEIGHT, o retorno será BASEWIDTH e MIN_HEIGHT. A mesma lógica é utilizada
            quando a altura é considerada a medida de referência. Esse processo é realizado para evitar que imagens
            que possuem grandes dimensões não sejam um obstáculo para utilização.
            </p>

            <h5><b>3. Conversão imagem para array:</b></h5>
            Usando a biblioteca do numpy foi feita a conversão para array, np.array, como a imagem já está
            convertida em escala de cinza, o resultado é uma matriz de apenas uma dimensão.</p>
            A imagem de teste convertida para matriz multidimensional foi esta:</p>
            <div class="col-xl-10 col-lg-7"><img class="img-fluid mb-3 mb-lg-0" src="assets/img/pixel.png"
                                                 alt="..."/></div>
            </br>
            1x4 pixels e de cores simples.</p>
            O resultado gerado pelo código foi o seguinte:</p>
            <div class="col-xl-10 col-lg-7"><img class="img-fluid mb-3 mb-lg-0" src="assets/img/matrix_result.png"
                                                 alt="..."/></div>
            </br>
            No caso a imagem é RGBA. Onde o primeiro array é referente ao primeiro pixel, os valores são bem
            próximos a 255, mostrando que o pixel tende a branco.</p>
            <div class="col-xl-10 col-lg-7"><img class="img-fluid mb-3 mb-lg-0"
                                                 src="assets/img/matrix_result_normalize.png" alt="..."/></div>
            </br>
            Posteriormente foi normalizada a saída dividindo os valores por 255.</p>


            <h5><b>4. Criação do objeto:</b></h5>
            O objeto que será criado apresentará os seguintes parâmetros:<br/>
            name -> nome do arquivo com extensão.<br/>
            data -> data do dia da conversão.<br/>
            width -> largura da imagem definida pela função de redução de tamanho.<br/>
            height -> altura da imagem definida pela função de redução de tamanho.<br/>
            array -> imagem convertida em array.</p>

            <h5><b>5. Armazenar no MongoDb:</b></h5>
            Ao terminar a criação dos objetos para a quantidade de imagens definidas no contador, será salvo no
            MongoDB Atlas no formato de documento.<br/>
            As imagens listadas, que foram convertidas e salvas no MongoDB, serão movidas do container principal
            para o container de backup. <br/>
            Os parâmetros para definir os nomes são AZURE_CONTAINER e AZURE_BACKUP.</p>

            <h5><b>6. Validação do processo:</b></h5>
            Finalizando esse ciclo, ocorre a validação da lista gerada no começo da aplicação. Os arquivos que
            foram processados, serão removidos da lista. </p>
            <!--            Cada lote de processamento é feita a comparação com a lista que-->
            <!--            se encontra no backup, caso esteja faltando alguma imagem, é feita o reprocessamento somente desta. Quando-->
            <!--            a lista estiver vazia o processo terá sido encerrado.-->
            <h5><b>7. Criação de arquivo com amostras:</b></h5>
            Antes de encerrar o processamento, é gerado um arquivo zip, nele contém algumas imagens de amostra. As
            imagens são escolhidas aleatoriamente e podem ser definidas a quantidade pelo parâmetro
            QUANTIDADE_IMAGEM e respeitando a regra de amostragem.</p>

            <p><br/>
            </p>
        </div>
    </div>
</section>
<footer class="footer bg-black small text-center text-white-50">
    <div class="container px-4 px-lg-5">Copyright &copy; Fernando Oliveira Pereira 2021</div>
</footer>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
<script src="js/scripts.js"></script>
<script src="https://cdn.startbootstrap.com/sb-forms-latest.js"></script>
</body>

</html>